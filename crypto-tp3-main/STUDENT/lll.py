from math import *
from gramschmidt import *

# the two conditions to be achieved;
# they depend on the basis b and its gram-schmidt versions b*
# 1 \leq i < j ,=len(b)

# small product condition
def IP(b, bstar, i, j):
    n = len(b)
    nstar = len(bstar)
    assert (n == nstar and 1 <= j and j < i and i <= n)
    mij = pr_coeff(b[i-1], bstar[j-1])
    cond = abs(mij) <= 1/2
    return cond

# long enough projection condition
def IL(b, bstar, i):
    n = len(b)
    nstar = len(bstar)
    assert (n == nstar and 2 <= i and i <= n)
    normi = np.dot(bstar[i-1], bstar[i-1])
    # mu(i,i-1)
    m = pr_coeff(b[i-1], bstar[i-2])
    normim1 = np.dot(bstar[i-2], bstar[i-2])
    cond = (normi+(m*m)*normim1 >= 3/4*normim1)
    return cond

# returns the integer closest to x
def closint(x: float):
    f = floor(x)
    if (x-f) < 1/2:
        return f
    else:
        return f+1

# tests that b fulfills both LLL conditions
def isLLL(b: array):
    n = len(b)
    bstar = gs(b)
    res = True
    for i in range(2, n+1):
        if not IL(b, bstar, i):
            print(" test IL fails for i =", i)
            res = False
        for j in range(1, i):
            if not IP(b, bstar, i, j):
                print("test IP fails for i j =", i, j)
                res = False
    return res

# arg binit is a base (on R) (an array of dim 2); the vectors are the lines of the array.
# returns a new basis, for the lattice generated by b, which is reduced in the sense of [LLL 1982]
def LLL(binit: array):
    n = len(binit)
    b = np.copy(binit)
    bstar = gs(b)
    k = 2
    while k <= n:
        if k == 1:
            k = k+1
        else:
            if not IP(b, bstar, k, k-1):
                # reduce bk
                coeff = closint(pr_coeff(b[k-1], bstar[k-2]))
                temp = np.copy(b)
                b[k-1] = temp[k-1] - np.dot(coeff, temp[k-2])
                bstar = gs(b)
            if not IL(b, bstar, k):
                # swapp b_k,b_{k-1}
                temp = np.copy(b)
                b[k-1] = temp[k-2]
                b[k-2] = temp[k-1]
                bstar = gs(b)
                k = k-1
            # if IL(b,bstar,k):
            else:
                for l in range(k-2, 0, -1):
                    # case where |mu(k,l)|>1/2
                    mu = pr_coeff(b[k-1], bstar[l-1])
                    if abs(mu) > 1/2:
                        # reduce bk
                        coeff = closint(mu)
                        temp = np.copy(b)
                        b[k-1] = temp[k-1] - np.dot(coeff, temp[l-1])
                        bstar = gs(b)
                k = k+1
    assert isLLL(b)
    return b
